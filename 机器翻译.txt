机器翻译任务代码总结如下
数据预处理
1.读取数据，处理数据中的编码问题，交替无效的字符串删除
2.分词，分词的目的就是将字符串转换成单词组成的列表。
   目前有很多现成的分词工具可以直接使用，也可以直接按照间隔进行分词（不推荐，因为分词不是很准确）
3.建立字典，将单词组成的列表编程单词id组成的列表，这里会得到如下几样东西
   1.去重后词典，及其中单词对应的索引列表
   2.还可以得到给定索引找到其对应的单词的列表，以及给定单词得到对应索引的字典。
   3.原始语料所有词对应的词典索引的列表
4.对数据进行填充操作。因为机器翻译模型本质上是一个固定输入长度的Seq2Sqe模型，所以我们需要设置最大的数据长度，
   如果超过了设定的长度直接把后面的截断，少了的，根据需要进行不同的padding
5.制作数据生成器，但是需要注意的是关于翻译任务的数据格式，机器翻译的输入是一段文本序列，输出也是一段文本序列。

Seq2Seq模型的内置
1. Seq2Seq模型由很多钟，但是整体框架都是基于先编码后解码的框架。
   也就是先对输入序列使用循环神经网络对他进行编码，编码成一个向量之后，
   再将编码得到的向量作为一个新的解码循环神经网络的隐藏状态的输入，进行解码，一次输出一个序列的元素，
   再将模型训练输出的序列元素与真实标签计算损失进行学习。
2.词嵌入，一般情况下输入到编码网络中的数据不是一个onehot向量串行经过了编码之后的向量，
   而是由word2vec技术，让编码后的向量由更加丰富的含义。
3.在进行编码和解码的过程中数据都是以时间步展开，也就是（Seq_len，）这种形式的数据进行处理的
4.对于编码与解码的循环神经网络，可以通过控制隐藏层的层数及每一层隐藏层神经元的数量来控制模型的复杂度
5.编码部分，RNN的用0初始化隐含状态，最后的输出主要是隐藏状态，编码RNN输出的隐含状态认为是其对应的编码向量
6.解码器的整体形状与编码器是一样的，只不过解码器的模型的隐藏状态是由编码器的输出的隐藏状态初始化的。

损失函数
1.解码器的输出是一个和词典索引相同的向量，其每个值对应与矢量索引位置对应词的分数，通常是选择分数最大的那个词作为最终的输出。
2.在计算损失函数之前，要把padding去掉，因为padding的部分不参与计算

测试
1.解码器在测试的时候需要将模型的输出作为下一个时间步的输入
2. Beam Search搜索算法。
   1.假设预测的时候词典的大小为3，内容为a，b，c。beam size为2，解码的时候过程如下
   2.生成第一个词的时候，选择概率最大的两个词，假设为a，c。那么当前的两个序列就是a和c。
   3.生成第二个词的时候，将当前序列a和c，分别作为表表的所有词进行组合，得到新的6个序列aa ab ac ca cb cc，
      计算每个序列的注释，并选择精彩最高的2个序列，作为新的当前序列，假如为aa cb 
   4.后面不断重复这个过程，直到遇到结束符或达到最大长度为止，最终输出最高的2个序列。